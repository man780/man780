# Основные принципы ООП

## Инкапсуляция
Инкапсуляция означает упаковку данных и методов, работающих с этими данными, в единый компонент, называемый класс. Объекты класса могут взаимодействовать только через интерфейс, который класс предоставляет для работы с данными.

## Наследование
Наследование позволяет создавать новые классы на основе уже существующих. Подкласс (или производный класс) наследует свойства и методы суперкласса (или базового класса) и может добавлять или переопределять их.

## Полиморфизм
Полиморфизм позволяет использовать один и тот же интерфейс для различных типов объектов. Это может быть реализовано через перегрузку методов или использование интерфейсов.

## Абстракция
Абстракция представляет собой создание упрощенной модели объекта, отбрасывая ненужные детали. Абстрактные классы и интерфейсы помогают создавать абстракции в объектно-ориентированном программировании.

# SOLID

SOLID - это акроним, представляющий собой пять основных принципов объектно-ориентированного программирования и проектирования.

## 1. Принцип единственной ответственности (Single Responsibility Principle, SRP)
Класс должен иметь только одну причину для изменения, то есть он должен выполнять только одну задачу.

## 2. Принцип открытости/закрытости (Open/Closed Principle, OCP)
Программные сущности должны быть открыты для расширения, но закрыты для модификации. Это означает, что поведение сущности можно расширять без изменения её исходного кода.

## 3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
Объекты базового класса должны быть заменяемыми объектами производного класса без изменения корректности программы.

## 4. Принцип разделения интерфейса (Interface Segregation Principle, ISP)
Клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что интерфейсы должны быть разделены на более мелкие, специфические части.

## 5. Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)
Зависимость на абстракциях, а не на деталях. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.

# Разница между классовым и прототипным наследованием

## Классовое наследование
Классовое наследование предполагает создание объектов на основе классов, которые могут быть рассмотрены как шаблоны. Он использует явное определение классов и ключевое слово `class` в языках, поддерживающих классы.

## Прототипное наследование
Прототипное наследование использует объекты-прототипы, которые служат в качестве шаблонов для создания новых объектов. Он обычно реализуется через механизмы, предоставляемые языками, такими как JavaScript.

# Однонаправленный поток данных и двусторонняя связь данных

## Однонаправленный поток данных
Однонаправленный поток данных означает передачу данных от родительского компонента к дочернему компоненту в приложении. Изменения в родительском компоненте влияют на дочерний компонент, но не наоборот.

## Двусторонняя связь данных
Двусторонняя связь данных позволяет передавать данные как от родительского к дочернему компоненту, так и от дочернего к родительскому. Это обеспечивает взаимное влияние изменений в обоих направлениях.

# Функциональное программирование

Функциональное программирование (ФП) - это парадигма программирования, в которой программы рассматриваются как вычисления математических функций, а изменение состояния и мутабельность считаются нежелательными. ФП поддерживает использование функций высших порядков, чистые функции, рекурсию и другие концепции.

# MVC (Model-View-Controller)

MVC - это архитектурный паттерн, который разделяет приложение на три основных компонента:

- **Модель (Model):** Представляет собой данные и бизнес-логику приложения.
- **Вид (View):** Отвечает за отображение данных и взаимодействие с пользователем.
- **Контроллер (Controller):** Обрабатывает пользовательский ввод, взаимодействует с моделью и обновляет представление.

# MVVM (Model-View-ViewModel)

MVVM - это архитектурный паттерн, который расширяет MVC. В нем добавляется еще один компонент:

- **ViewModel:** Связывает модель и представление, предоставляя специальные объекты (ViewModels) для отображения данных и обработки пользовательского ввода.

# MVP (Model-View-Presenter)

MVP - еще один вариант архитектурного паттерна, похожий на MVC, но с некоторыми различиями:

- **Презентер (Presenter):** Заменяет контроллер и обрабатывает пользовательский ввод, обновляя модель и представление.

# Недостатки паттерна MVW (Model-View-Whatever)

MVW - общий термин, объединяющий различные архитектурные паттерны, такие как MVC, MVVM, MVP. Недостатки могут включать сложность поддержки, возможные проблемы с читаемостью кода и избыточность компонентов.

**Функция:**
- Является независимой частью кода, которая принимает входные данные, выполняет операции и возвращает результат.
- Не привязана к какому-либо объекту или классу.

**Метод:**
- Привязан к объекту или классу и является частью их интерфейса.
- Вызывается на конкретном объекте и может иметь доступ к его состоянию.

# Каррирование (Currying)

Каррирование - это техника в функциональном программировании, при которой функция с несколькими аргументами преобразуется в последовательность функций с одним аргументом. Это позволяет частичное применение функций и создание новых функций на основе существующих.

# Разница между ООП и ФП в JavaScript

**ООП в JavaScript:**
- Основано на объектах и классах.
- Использует концепции наследования и инкапсуляции.
- Объекты могут иметь методы и свойства.

**ФП в JavaScript:**
- Функции являются основными строительными блоками.
- Избегает изменяемого состояния и побуждает использование чистых функций.
- Поддерживает функции высшего порядка, замыкания и рекурсию.

# Плюсы и минусы ФП и ООП

**ФП:**
- *Плюсы:*
  - Избегание изменяемого состояния упрощает отладку.
  - Функции высшего порядка и замыкания способствуют чистому коду.
- *Минусы:*
  - Могут возникнуть сложности при использовании в императивных задачах.
  - Некоторые разработчики могут найти функциональный стиль менее интуитивным.

**ООП:**
- *Плюсы:*
  - Управление сложностью с использованием объектов и их взаимодействия.
  - Использование наследования может способствовать повторному использованию кода.
- *Минусы:*
  - Может привести к сложному иерархическому коду.
  - Возможно изменение состояния, что может затруднить отладку.

# Разница между монолитной и микросервисной архитектурами

## Монолитная архитектура
- **Описание:** Все компоненты приложения развиваются, развертываются и масштабируются как единое целое.
- **Плюсы:**
  - Проще в разработке и тестировании.
  - Единое развертывание и масштабирование.
- **Минусы:**
  - Сложнее масштабировать отдельные части при росте.
  - Ограниченная независимость компонентов.

## Микросервисная архитектура
- **Описание:** Приложение состоит из небольших, автономных сервисов, каждый из которых выполняет отдельную функцию.
- **Плюсы:**
  - Легко масштабировать и обновлять отдельные сервисы.
  - Высокая гибкость и независимость компонентов.
- **Минусы:**
  - Сложнее в общей разработке и тестировании.
  - Дополнительная сложность в управлении распределенной системой.

# Плюсы и минусы монолитной и микросервисной архитектур

## Монолитная архитектура
- *Плюсы:*
  - Простота разработки и тестирования.
  - Одно развертывание и масштабирование.
- *Минусы:*
  - Сложность масштабирования при росте.
  - Ограниченная независимость компонентов.

## Микросервисная архитектура
- *Плюсы:*
  - Легкость масштабирования и обновления.
  - Высокая гибкость и независимость компонентов.
- *Минусы:*
  - Сложность в общей разработке и тестировании.
  - Управление распределенной системой.

# Принципы, которые можно использовать вместе с наследованием

- **Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):** Объекты базового и производного классов можно использовать взаимозаменяемо.

# Принципы, кроме SOLID

- **Принцип единственной ответственности (Single Responsibility Principle, SRP):** Каждый класс должен иметь только одну причину изменения.
- **Принцип открытости/закрытости (Open/Closed Principle, OCP):** Программные сущности должны быть открыты для расширения, но закрыты для модификации.
- **Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):** Зависимости должны строиться относительно абстракций, а не деталей.

# Дескрипторы свойств объектов

- **Дескриптор свойства:** Это объект, который определяет, как свойство должно быть определено, настроено и доступно.

# Особенности геттеров и сеттеров

- **Геттеры и сеттеры:** Это методы, предназначенные для получения и установки значений свойств объекта. Особенности включают в себя контроль доступа к данным и выполнение дополнительных действий при их получении или установке.

# Статический метод класса (static)

- **Статический метод:** Принадлежит классу, а не экземпляру. Вызывается на самом классе, а не на объекте. Осуществляется через имя класса, например, `ClassName.method()`.

# Разница между композицией и наследованием

- **Наследование:** Позволяет классу наследовать свойства и методы другого класса.
- **Композиция:** Позволяет объекту включать в себя другие объекты в качестве своих частей.

# Композиция в контексте JavaScript

- **Композиция в JavaScript:** Включение объекта в другой объект для повторного использования функциональности. Может осуществляться через свойства объекта или передачу объекта в качестве параметра функции.

# Паттерн, или шаблон проектирования

## Паттерн проектирования
- **Описание:** Повторяемое решение для общей проблемы в конкретном контексте. Он предоставляет абстракцию для решения типовых задач, улучшает повторное использование кода и делает систему более гибкой.

# Типы паттернов

## Типы паттернов
- **Порождающие паттерны:** Занимаются процессом создания объектов.
- **Структурные паттерны:** Касаются композиции объектов.
- **Поведенческие паттерны:** Определяют способы взаимодействия объектов.

# GOF паттерны

## GOF паттерны
- **Описание:** Паттерны, представленные в книге "Design Patterns: Elements of Reusable Object-Oriented Software" Гаммы, Хелма, Джонсона и Влиссидеса.
- **Примеры:** Фабрика, Строитель, Декоратор, Наблюдатель и т.д.

# GRASP паттерны

## GRASP паттерны
- **Описание:** Паттерны проектирования, ориентированные на архитектуру программы и обязанности объектов.
- **Примеры:** Создатель, Контроллер, Информационный эксперт и т.д.

# Типы полиморфизма

## Полиморфизм
- **Описание:** Возможность объектов с разными типами быть обработанными с использованием общего интерфейса.
- **Типы:**
  - **Компайл-тайм (статический) полиморфизм:** Реализуется на этапе компиляции, например, перегрузка методов.
  - **Рантайм (динамический) полиморфизм:** Реализуется на этапе выполнения, например, через наследование и виртуальные методы.

# Вопросы по JavaScript

## Абстрактный класс в JavaScript
- **Возможность:** JavaScript не предоставляет непосредственной поддержки абстрактных классов.
- **Реализация:** Можно имитировать абстрактные классы через функции-конструкторы, генерацию ошибок при создании экземпляров, или использование классов в современных версиях языка.

# Механизм прототипов в JavaScript

## Прототипы в JavaScript
- **Описание:** В JavaScript, объекты могут наследовать свойства и методы другого объекта через механизм прототипов.
- **Работа:** Каждый объект имеет ссылку на свой прототип, и если свойство или метод не найдены в самом объекте, поиск продолжается в его прототипе.

